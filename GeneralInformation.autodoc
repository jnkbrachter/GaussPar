@AutoDocPlainText
@Chapter The GaussPar package
@Section What Is This Package About?

This package implements a parallel version of the GAUSS algorithm which divides
a given matrix in smaller blocks, executes the GAUSS algorithm on the blocks
simultaneously using different kernels and merges the result in a thought out
way. We realize the algorithm that is described in the paper "A parallel
algorithm for Gaussian elimination over finite fields" (Linton et al. 2018)
@BeginLatexOnly
\footnote{Linton, S., Nebe, G., Niemeyer, A., Parker, R. and Thackray, J. (2018).
A parallel algorithm for Gaussian elimination over finite fields.}
@EndLatexOnly

To make our package user-friendly we provide different versions of the main
function returning different amounts of information and options to influence the 
process of calculation. While creating the main functions we implemented many
low-level functions and found that some of them could be useful independently.
The exact documentation of all those functions can be found in chapter 2.
Examples for the main functions are in chapter 3.

@Section Technical Background

Our syntax is based on the GAP package "GAUSS"
@BeginLatexOnly
\footnote{\url{https://www.gap-system.org/Packages/gauss.html}}
@EndLatexOnly
by Simon Goertzen which provides an implementation of the sequential GAUSS algorithm, meaning
that we tried to name our functions similarily.


To use our package one needs to download it
@BeginLatexOnly
\footnote{Download for example from our github repository:
\url{https://github.com/lbfm-rwth/GaussPar/}}
@EndLatexOnly
, navigate inside the directory, open HPCGAP and type
@BeginExampleSession
#! gap> LoadPackage( "GAUSSPAR" );
@EndExampleSession
Then you can start by following the examples in chapter 3.

@Chapter Gaussian Elimination
@Section Gaussian Elimination

In this section there are the specifications of the variants of our implementation
of the GAUSS algorithm. For example usage see chapter 3.

@Chapter Utility Functions
@Section Utility Functions

The following functions were created while implementing the high-level functions,
but we found that they could be useful outside of our functions, too.
You can find the specifications of the functions and some small examples here.

@Chapter Examples

To understand the usage of our high level functions (that are basically
different versions of the same algorithm), I will show you some examples that
transform the following random matrix A.

@BeginExampleSession
#! gap> A := RandomMat( 40, 40, GF( 5 ) );
#! gap> Display( A );
#! . 3 4 1 4 4 . 2 4 . 3 2 . 1 1 . 3 2 3 3 3 3 2 . 2 2 4 4 3 1 2 2 4 1 . 1 3 1 2 4
#! 4 3 . . . . 4 2 1 1 2 3 2 3 3 1 2 3 1 4 2 1 3 2 4 . 1 3 2 3 2 3 2 4 3 4 . . 1 4
#! 3 4 2 1 2 1 3 . 4 3 . 2 2 4 2 . 3 2 1 1 4 4 4 2 4 2 . 4 2 . . 3 3 . 4 2 . 1 . .
#! 2 2 . 3 2 4 . 2 3 4 4 3 1 1 3 1 2 3 4 3 2 1 4 . 4 4 . 2 2 3 . 1 2 1 1 2 4 2 4 .
#! 3 1 2 . 3 3 . 2 1 1 3 2 . 3 1 . . 3 3 4 . 1 . 2 . 3 4 2 4 . 3 2 . 1 2 2 . 4 4 2
#! 2 2 1 2 . 4 . . 4 4 2 3 3 1 2 4 1 3 2 1 4 2 . . 3 4 1 . 3 1 3 4 4 2 2 . 4 3 2 .
#! 4 1 1 3 4 2 3 1 2 3 . . 4 3 1 1 4 4 2 3 3 2 4 4 4 3 2 . . 3 2 1 . 4 2 . 3 2 1 1
#! . 4 2 . 4 3 2 1 3 2 1 3 . 2 4 1 4 . 4 4 4 1 . . 1 1 2 4 . 3 1 2 1 1 1 4 . . 4 4
#! 3 3 1 1 3 1 2 3 1 3 2 . 2 2 3 1 3 4 1 1 4 4 4 2 4 3 1 4 3 2 2 1 3 4 2 1 4 . 1 .
#! 3 3 4 1 1 3 2 4 4 . 3 . 2 . 3 . 1 . 2 1 2 2 1 2 3 4 1 . 3 4 2 4 . 2 1 . 1 2 4 .
#! 4 1 4 4 . 3 3 1 2 3 4 . 3 1 4 4 . 4 4 1 4 2 2 . . 3 3 2 2 1 4 . 2 1 3 3 3 . 2 3
#! 4 4 . 1 . 3 3 1 2 4 . 2 2 . 4 4 2 3 3 . . 4 3 3 1 1 2 1 . 3 4 . . 3 . 4 . 4 3 4
#! . 4 3 3 2 3 2 . 1 1 1 2 3 2 . 2 1 3 4 1 1 3 3 4 3 3 2 2 4 . 2 4 3 2 3 . . 3 . .
#! 2 4 3 . 1 . 1 3 2 . . . 3 3 4 2 3 3 3 3 1 3 4 2 . 1 3 4 2 4 3 . . 3 1 2 3 1 3 1
#! 2 4 4 2 1 1 . 3 4 1 . 1 2 4 3 4 . 3 . . 3 . 4 1 3 1 4 . 3 . 4 1 3 4 . 1 4 4 2 2
#! 4 4 4 4 3 . 3 3 . 2 4 . 4 4 3 1 3 4 2 2 2 3 3 3 2 4 1 3 4 . 3 . 3 4 2 2 4 4 4 1
#! 2 . 4 3 2 4 . 2 2 2 2 1 4 2 3 . 4 2 . 2 1 . 4 . 2 . 2 4 3 . 1 . 3 . 1 4 4 2 . 4
#! 3 2 2 . 2 4 3 3 2 4 1 4 . . 1 4 3 1 4 3 . 2 . 2 4 1 4 . 4 4 2 1 2 3 4 1 3 1 2 2
#! 2 . 1 1 . 4 . 3 1 3 . . . . 2 3 1 3 2 . . 2 . . 1 4 1 . . 4 1 3 2 3 . 2 4 3 . 3
#! 1 4 . 1 . 3 . 1 3 1 . 4 4 3 4 4 4 3 . 3 3 . 2 3 2 . 4 1 3 4 2 1 1 2 3 1 3 1 2 .
#! 2 4 . 2 3 1 4 4 1 2 2 1 4 2 1 3 2 . 3 1 2 3 . 1 2 . . 1 1 4 4 3 2 3 4 3 . 1 1 2
#! . . 2 4 2 1 . 4 2 1 2 . 1 3 4 4 . 3 . 2 2 . 4 1 2 . . . . 2 4 . 3 2 1 3 2 1 4 .
#! . 3 2 1 2 . . 1 1 2 4 2 3 2 2 2 3 . . 4 2 4 1 4 4 3 2 2 4 1 1 4 4 4 3 4 3 1 4 3
#! . 2 3 3 4 4 3 . 2 2 . 1 3 . 3 4 4 2 . 2 1 . 2 4 4 3 4 4 4 . . 1 1 1 3 2 1 3 3 2
#! . 2 3 1 4 4 4 4 4 . 1 4 3 4 2 . 4 3 . 4 4 1 3 . 1 4 . 4 1 2 2 4 . 1 3 3 . 4 4 4
#! 1 1 2 4 3 3 1 4 4 . 2 4 3 3 1 4 3 3 1 . 1 3 2 3 1 4 3 3 1 4 4 3 4 4 2 2 1 1 4 4
#! 2 3 1 . 2 4 1 1 1 . 3 4 4 . 1 1 3 4 . 4 3 2 3 2 1 . 1 1 1 1 1 4 . 1 2 3 . 2 3 2
#! . 2 1 . 1 4 3 1 4 . 2 2 3 4 1 2 . 3 . . 3 4 2 1 1 3 4 3 1 1 3 . 3 . 3 4 4 3 3 3
#! 1 1 2 2 . 1 . 4 4 1 1 . 3 2 1 . . 4 2 1 . . 3 3 3 4 . 2 1 4 1 1 1 3 3 4 1 3 4 4
#! 3 4 2 4 1 1 . 1 4 3 4 1 1 1 . 2 . 1 2 4 4 . 2 1 3 4 1 . 4 1 2 4 . 1 1 4 1 1 4 2
#! 2 4 2 . 4 1 4 . 3 2 3 . 1 3 1 4 2 4 2 2 3 1 4 4 4 1 1 4 . . 2 . 3 3 1 3 2 . 3 3
#! 2 . . 3 . . 3 3 3 . . 1 1 . 2 4 1 1 . . 1 1 1 . 3 1 2 1 2 4 3 3 2 4 . 4 . 3 4 4
#! . 3 . 2 3 4 1 1 3 . 1 3 3 . 1 4 1 4 . 4 4 4 2 . 1 3 4 3 3 . 2 4 . 1 1 1 2 4 3 3
#! 4 3 . 1 3 1 2 4 2 1 1 4 3 . 2 1 2 . 4 . 1 4 2 2 1 2 4 . 2 3 3 2 1 2 4 2 2 3 3 3
#! 1 . . 2 4 4 4 3 4 1 4 4 2 . 1 3 . 1 3 4 3 1 2 4 3 2 . 1 4 3 1 4 4 2 4 2 . . 4 3
#! 1 . 2 4 4 1 3 4 4 3 1 4 3 2 2 4 2 4 . 2 1 1 3 1 4 . 3 4 2 1 3 2 4 2 1 4 4 1 4 3
#! 4 . 4 1 1 2 1 4 4 . 3 2 . . 2 1 . 3 2 2 4 2 . 2 . 3 3 1 1 1 4 . 3 4 4 4 2 . 1 2
#! 2 4 3 . 4 2 1 . 1 . 4 3 4 3 1 2 4 . 3 2 . 4 3 2 1 2 3 3 4 3 . 4 4 . 4 3 3 . 4 .
#! 2 2 . 3 1 3 3 4 2 2 1 1 2 2 1 1 4 4 . 4 2 . 2 4 3 . 4 2 3 4 2 4 . 3 . 4 3 . 3 .
#! 2 4 1 3 2 3 3 . 1 . 4 3 . 2 2 3 . 2 3 1 1 1 2 3 . 4 1 3 1 . 3 3 4 . 3 2 . 4 4 4
@EndExampleSession

This is the most basic version which takes the matrix as the argument and
calculates all the other informations automatically. You can not set any
additional parameters and the return value is a record which contains the
positions of the pivot elements and the vectors of the transformed matrix
without the rows containing only zeros.

@BeginExampleSession
#! gap> result := EchelonMatBlockwise( A );
#! #I  The matrix is split into 4 blocks vertically and 4 horizontally.
#! rec( heads := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
#!   19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
#!     vectors := < immutable compressed matrix 28x40 over GF(5) > )
#! gap> Display( result.vectors );
#! 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 4 4 . 1 3 2 4 3 . 3
#! . 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 . 2 2 3 4 2 2 2 4 1
#! . . 1 . . . . . . . . . . . . . . . . . . . . . . . . . 4 . 3 3 3 1 . 1 3 1 . 4
#! . . . 1 . . . . . . . . . . . . . . . . . . . . . . . . 4 2 1 1 4 3 . . 3 4 1 2
#! . . . . 1 . . . . . . . . . . . . . . . . . . . . . . . . 4 2 4 3 2 1 2 2 . 4 .
#! . . . . . 1 . . . . . . . . . . . . . . . . . . . . . . 2 1 3 2 1 4 . 4 4 1 2 4
#! . . . . . . 1 . . . . . . . . . . . . . . . . . . . . . 1 . 3 4 . 3 . 2 3 1 2 1
#! . . . . . . . 1 . . . . . . . . . . . . . . . . . . . . 3 3 . 4 4 2 2 2 1 3 3 1
#! . . . . . . . . 1 . . . . . . . . . . . . . . . . . . . 3 2 4 4 . 3 4 3 2 4 2 2
#! . . . . . . . . . 1 . . . . . . . . . . . . . . . . . . . 3 4 3 1 . 1 2 2 . 1 .
#! . . . . . . . . . . 1 . . . . . . . . . . . . . . . . . 2 . 3 1 1 1 . 4 4 1 2 2
#! . . . . . . . . . . . 1 . . . . . . . . . . . . . . . . 1 3 4 1 1 4 3 1 1 2 2 .
#! . . . . . . . . . . . . 1 . . . . . . . . . . . . . . . 1 3 4 4 3 4 . 3 . 2 1 3
#! . . . . . . . . . . . . . 1 . . . . . . . . . . . . . . . 3 1 1 2 . 3 . 2 1 1 .
#! . . . . . . . . . . . . . . 1 . . . . . . . . . . . . . . 2 2 . 3 4 3 . 4 . 2 1
#! . . . . . . . . . . . . . . . 1 . . . . . . . . . . . . 4 3 . . . 2 3 . 3 . 3 3
#! . . . . . . . . . . . . . . . . 1 . . . . . . . . . . . 4 4 1 2 . . 4 . 2 3 . 4
#! . . . . . . . . . . . . . . . . . 1 . . . . . . . . . . . . 4 3 4 3 1 3 3 3 . 1
#! . . . . . . . . . . . . . . . . . . 1 . . . . . . . . . 1 . 3 3 4 4 4 4 1 1 1 3
#! . . . . . . . . . . . . . . . . . . . 1 . . . . . . . . . 1 2 3 1 2 . 2 3 3 2 2
#! . . . . . . . . . . . . . . . . . . . . 1 . . . . . . . 1 2 4 3 . 2 3 4 2 3 3 3
#! . . . . . . . . . . . . . . . . . . . . . 1 . . . . . . 2 3 4 3 2 1 1 2 . 1 4 2
#! . . . . . . . . . . . . . . . . . . . . . . 1 . . . . . 2 1 4 1 4 2 4 4 3 . . 1
#! . . . . . . . . . . . . . . . . . . . . . . . 1 . . . . 4 4 3 4 1 2 4 3 2 . 1 2
#! . . . . . . . . . . . . . . . . . . . . . . . . 1 . . . 3 . 3 . 4 2 . 3 3 2 2 .
#! . . . . . . . . . . . . . . . . . . . . . . . . . 1 . . 4 . . 2 3 2 1 3 4 1 . 1
#! . . . . . . . . . . . . . . . . . . . . . . . . . . 1 . 1 3 2 2 . 4 . . 4 3 2 3
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 2 3 4 3 3 1 1 . 3 4 4 .
@EndExampleSession

This version returns additionally two lists of vectors with whom one can calculate
the transformation matrix that is used to obtain the RREF form of the matrix.

@BeginExampleSession
#! gap> result2 := EchelonMatTransformationBlockwise( A );
#! #I  The matrix is split into 4 blocks vertically and 4 horizontally.
#! rec( coeffs := < immutable compressed matrix 28x40 over GF(5) >,
#!     heads := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
#!       20, 21, 22, 23, 24, 25, 26, 27, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
#!     relations := < immutable compressed matrix 12x40 over GF(5) >,
#!     vectors := < immutable compressed matrix 28x40 over GF(5) > )
#! gap> Display( result2.relations );
#! 4 4 3 1 2 1 . 4 . 3 4 2 4 3 . 2 1 . 1 3 3 . 2 1 . 3 3 . 1 . . . . . . . . . . .
#! . 2 2 2 3 4 1 2 3 . 3 1 2 1 3 3 2 . 3 4 1 2 3 . 1 . 1 1 . 1 . . . . . . . . . .
#! 2 . 4 . . 2 4 2 4 . . 1 1 4 3 3 2 . . . 4 . 1 1 1 2 . 4 . . 1 . . . . . . . . .
#! 1 2 . 2 2 . 3 4 3 4 1 1 . 3 2 4 . 3 2 3 2 . 2 3 1 2 3 4 . . . 1 . . . . . . . .
#! 3 2 3 1 2 . 3 3 1 4 2 . 3 1 . 3 . 1 1 4 1 1 4 4 . 1 2 1 . . . . 1 . . . . . . .
#! 2 . 4 . 3 2 4 1 3 4 1 2 . 1 3 4 4 3 . 4 2 4 4 3 4 1 1 4 . . . . . 1 . . . . . .
#! . . 2 . . 3 2 . 3 2 4 3 4 . 1 . 2 2 1 3 3 3 3 2 2 3 . . . . . . . . 1 . . . . .
#! . 3 1 . 4 2 1 3 4 3 . 1 4 3 3 . 1 2 2 2 1 2 3 2 4 3 4 2 . . . . . . . 1 . . . .
#! 1 . 3 2 2 1 2 3 4 2 1 . 2 2 1 2 . 3 3 4 2 3 2 1 3 1 1 4 . . . . . . . . 1 . . .
#! 1 3 2 2 2 1 3 4 4 4 4 3 3 1 3 4 2 1 3 2 1 3 2 1 . 3 . . . . . . . . . . . 1 . .
#! 1 . 2 1 . . 4 . . 2 . 2 3 4 3 1 1 4 3 1 1 4 4 4 2 2 1 4 . . . . . . . . . . 1 .
#! 4 3 3 1 . 3 4 3 3 1 . 4 2 2 . 4 2 4 3 4 . 1 . . . 3 3 4 . . . . . . . . . . . 1
#! gap> Display( Concatenation( result2.coeffs, result2.relations ) * A );
#! 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 4 4 . 1 3 2 4 3 . 3
#! . 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 . 2 2 3 4 2 2 2 4 1
#! . . 1 . . . . . . . . . . . . . . . . . . . . . . . . . 4 . 3 3 3 1 . 1 3 1 . 4
#! . . . 1 . . . . . . . . . . . . . . . . . . . . . . . . 4 2 1 1 4 3 . . 3 4 1 2
#! . . . . 1 . . . . . . . . . . . . . . . . . . . . . . . . 4 2 4 3 2 1 2 2 . 4 .
#! . . . . . 1 . . . . . . . . . . . . . . . . . . . . . . 2 1 3 2 1 4 . 4 4 1 2 4
#! . . . . . . 1 . . . . . . . . . . . . . . . . . . . . . 1 . 3 4 . 3 . 2 3 1 2 1
#! . . . . . . . 1 . . . . . . . . . . . . . . . . . . . . 3 3 . 4 4 2 2 2 1 3 3 1
#! . . . . . . . . 1 . . . . . . . . . . . . . . . . . . . 3 2 4 4 . 3 4 3 2 4 2 2
#! . . . . . . . . . 1 . . . . . . . . . . . . . . . . . . . 3 4 3 1 . 1 2 2 . 1 .
#! . . . . . . . . . . 1 . . . . . . . . . . . . . . . . . 2 . 3 1 1 1 . 4 4 1 2 2
#! . . . . . . . . . . . 1 . . . . . . . . . . . . . . . . 1 3 4 1 1 4 3 1 1 2 2 .
#! . . . . . . . . . . . . 1 . . . . . . . . . . . . . . . 1 3 4 4 3 4 . 3 . 2 1 3
#! . . . . . . . . . . . . . 1 . . . . . . . . . . . . . . . 3 1 1 2 . 3 . 2 1 1 .
#! . . . . . . . . . . . . . . 1 . . . . . . . . . . . . . . 2 2 . 3 4 3 . 4 . 2 1
#! . . . . . . . . . . . . . . . 1 . . . . . . . . . . . . 4 3 . . . 2 3 . 3 . 3 3
#! . . . . . . . . . . . . . . . . 1 . . . . . . . . . . . 4 4 1 2 . . 4 . 2 3 . 4
#! . . . . . . . . . . . . . . . . . 1 . . . . . . . . . . . . 4 3 4 3 1 3 3 3 . 1
#! . . . . . . . . . . . . . . . . . . 1 . . . . . . . . . 1 . 3 3 4 4 4 4 1 1 1 3
#! . . . . . . . . . . . . . . . . . . . 1 . . . . . . . . . 1 2 3 1 2 . 2 3 3 2 2
#! . . . . . . . . . . . . . . . . . . . . 1 . . . . . . . 1 2 4 3 . 2 3 4 2 3 3 3
#! . . . . . . . . . . . . . . . . . . . . . 1 . . . . . . 2 3 4 3 2 1 1 2 . 1 4 2
#! . . . . . . . . . . . . . . . . . . . . . . 1 . . . . . 2 1 4 1 4 2 4 4 3 . . 1
#! . . . . . . . . . . . . . . . . . . . . . . . 1 . . . . 4 4 3 4 1 2 4 3 2 . 1 2
#! . . . . . . . . . . . . . . . . . . . . . . . . 1 . . . 3 . 3 . 4 2 . 3 3 2 2 .
#! . . . . . . . . . . . . . . . . . . . . . . . . . 1 . . 4 . . 2 3 2 1 3 4 1 . 1
#! . . . . . . . . . . . . . . . . . . . . . . . . . . 1 . 1 3 2 2 . 4 . . 4 3 2 3
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 2 3 4 3 3 1 1 . 3 4 4 .
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
@EndExampleSession

This version is the most adjustable one - see chapter 2.2 for more information.
You can specify the field of the matrix and whether or not you need the
transformation matrix (extra calculation is needed, so it makes sense to
disable the calculation if you don't need it and calculate many matrices).

@BeginExampleSession
#! gap> DoEchelonMatTransformationBlockwise( A,
#! > rec( galoisField := GF( 5 ), withTrafo := false ) );
#! #I The matrix is split into 4 blocks vertically and 4 horizontally.
#! rec( coeffs := < immutable compressed matrix 28x40 over GF(5) >,
#!   heads := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
#!       20, 21, 22, 23, 24, 25, 26, 27, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
#!   pivotcols := [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
#!       1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
#!   pivotrows := [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
#!       1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
#!   rank := 28,
@EndExampleSession

Our package is still in a beta version and although we ran a lot of tests,
it makes sense to verify the results directly to be one hundred percent sure of
the outcome. If you pass the following argument, the function tests internally
before returning the results.

@BeginExampleSession
#! gap> DoEchelonMatTransformationBlockwise( A, rec( verify := true ) );
#! #I The matrix is split into 4 blocks vertically and 4 horizontally.
#! rec( coeffs := < immutable compressed matrix 28x40 over GF(5) >,
#!   heads := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
#!       20, 21, 22, 23, 24, 25, 26, 27, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
#!   pivotcols := [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
#!       1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
#!   pivotrows := [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
#!       1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
#!   rank := 28,
#!   relations := < immutable compressed matrix 12x40 over GF(5) >,
#!   transformation := < mutable compressed matrix 40x40 over GF(5) >,
#!   vectors := < immutable compressed matrix 28x40 over GF(5) > )
@EndExampleSession

Using the following arguments you can specify the number of blocks yourself.

@BeginExampleSession
#! gap> DoEchelonMatTransformationBlockwise( A,
#! > rec( numberBlocksHeight := 2, numberBlocksWidth := 4 ) );
#! #I The matrix is split into 2 blocks vertically and 4 horizontally.
#! rec( coeffs := < immutable compressed matrix 28x40 over GF(5) >,
#!   heads := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
#!       20, 21, 22, 23, 24, 25, 26, 27, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
#!   pivotcols := [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
#!       1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
#!   pivotrows := [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
#!       1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
#!   rank := 28,
#!   relations := < immutable compressed matrix 12x40 over GF(5) >,
#!   transformation := < mutable compressed matrix 40x40 over GF(5) >,
#!   vectors := < immutable compressed matrix 28x40 over GF(5) > )
@EndExampleSession

If you want to calculate the GAUSS algorithm on a matrix that is already
chopped (this could be useful for blocks of different sizes), write
TODO is this possible with blocks of different sizes??!!

@BeginExampleSession
#! gap> DoEchelonMatTransformationBlockwise( A, rec( isChopped := true ) );;
@EndExampleSession

@Chapter Low-Level Functions

@EndAutoDocPlainText
