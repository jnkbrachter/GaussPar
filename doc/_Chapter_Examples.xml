<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Examples">
<Heading>Examples</Heading>

<P/>
TODO: merge this into the Gaussian Elimination chapter. Also make
the matrices smaller or do not Display them.
<P/>
We showcase the usage of our main functions and their parameters by transforming
the follwoing random matrix A into its RREF.
<P/>
<Example><![CDATA[
#! gap> A := RandomMat( 40, 40, GF( 5 ) );
#! gap> Display( A );
#! . 3 4 1 4 4 . 2 4 . 3 2 . 1 1 . 3 2 3 3 3 3 2 . 2 2 4 4 3 1 2 2 4 1 . 1 3 1 2 4
#! 4 3 . . . . 4 2 1 1 2 3 2 3 3 1 2 3 1 4 2 1 3 2 4 . 1 3 2 3 2 3 2 4 3 4 . . 1 4
#! 3 4 2 1 2 1 3 . 4 3 . 2 2 4 2 . 3 2 1 1 4 4 4 2 4 2 . 4 2 . . 3 3 . 4 2 . 1 . .
#! 2 2 . 3 2 4 . 2 3 4 4 3 1 1 3 1 2 3 4 3 2 1 4 . 4 4 . 2 2 3 . 1 2 1 1 2 4 2 4 .
#! 3 1 2 . 3 3 . 2 1 1 3 2 . 3 1 . . 3 3 4 . 1 . 2 . 3 4 2 4 . 3 2 . 1 2 2 . 4 4 2
#! 2 2 1 2 . 4 . . 4 4 2 3 3 1 2 4 1 3 2 1 4 2 . . 3 4 1 . 3 1 3 4 4 2 2 . 4 3 2 .
#! 4 1 1 3 4 2 3 1 2 3 . . 4 3 1 1 4 4 2 3 3 2 4 4 4 3 2 . . 3 2 1 . 4 2 . 3 2 1 1
#! . 4 2 . 4 3 2 1 3 2 1 3 . 2 4 1 4 . 4 4 4 1 . . 1 1 2 4 . 3 1 2 1 1 1 4 . . 4 4
#! 3 3 1 1 3 1 2 3 1 3 2 . 2 2 3 1 3 4 1 1 4 4 4 2 4 3 1 4 3 2 2 1 3 4 2 1 4 . 1 .
#! 3 3 4 1 1 3 2 4 4 . 3 . 2 . 3 . 1 . 2 1 2 2 1 2 3 4 1 . 3 4 2 4 . 2 1 . 1 2 4 .
#! 4 1 4 4 . 3 3 1 2 3 4 . 3 1 4 4 . 4 4 1 4 2 2 . . 3 3 2 2 1 4 . 2 1 3 3 3 . 2 3
#! 4 4 . 1 . 3 3 1 2 4 . 2 2 . 4 4 2 3 3 . . 4 3 3 1 1 2 1 . 3 4 . . 3 . 4 . 4 3 4
#! . 4 3 3 2 3 2 . 1 1 1 2 3 2 . 2 1 3 4 1 1 3 3 4 3 3 2 2 4 . 2 4 3 2 3 . . 3 . .
#! 2 4 3 . 1 . 1 3 2 . . . 3 3 4 2 3 3 3 3 1 3 4 2 . 1 3 4 2 4 3 . . 3 1 2 3 1 3 1
#! 2 4 4 2 1 1 . 3 4 1 . 1 2 4 3 4 . 3 . . 3 . 4 1 3 1 4 . 3 . 4 1 3 4 . 1 4 4 2 2
#! 4 4 4 4 3 . 3 3 . 2 4 . 4 4 3 1 3 4 2 2 2 3 3 3 2 4 1 3 4 . 3 . 3 4 2 2 4 4 4 1
#! 2 . 4 3 2 4 . 2 2 2 2 1 4 2 3 . 4 2 . 2 1 . 4 . 2 . 2 4 3 . 1 . 3 . 1 4 4 2 . 4
#! 3 2 2 . 2 4 3 3 2 4 1 4 . . 1 4 3 1 4 3 . 2 . 2 4 1 4 . 4 4 2 1 2 3 4 1 3 1 2 2
#! 2 . 1 1 . 4 . 3 1 3 . . . . 2 3 1 3 2 . . 2 . . 1 4 1 . . 4 1 3 2 3 . 2 4 3 . 3
#! 1 4 . 1 . 3 . 1 3 1 . 4 4 3 4 4 4 3 . 3 3 . 2 3 2 . 4 1 3 4 2 1 1 2 3 1 3 1 2 .
#! 2 4 . 2 3 1 4 4 1 2 2 1 4 2 1 3 2 . 3 1 2 3 . 1 2 . . 1 1 4 4 3 2 3 4 3 . 1 1 2
#! . . 2 4 2 1 . 4 2 1 2 . 1 3 4 4 . 3 . 2 2 . 4 1 2 . . . . 2 4 . 3 2 1 3 2 1 4 .
#! . 3 2 1 2 . . 1 1 2 4 2 3 2 2 2 3 . . 4 2 4 1 4 4 3 2 2 4 1 1 4 4 4 3 4 3 1 4 3
#! . 2 3 3 4 4 3 . 2 2 . 1 3 . 3 4 4 2 . 2 1 . 2 4 4 3 4 4 4 . . 1 1 1 3 2 1 3 3 2
#! . 2 3 1 4 4 4 4 4 . 1 4 3 4 2 . 4 3 . 4 4 1 3 . 1 4 . 4 1 2 2 4 . 1 3 3 . 4 4 4
#! 1 1 2 4 3 3 1 4 4 . 2 4 3 3 1 4 3 3 1 . 1 3 2 3 1 4 3 3 1 4 4 3 4 4 2 2 1 1 4 4
#! 2 3 1 . 2 4 1 1 1 . 3 4 4 . 1 1 3 4 . 4 3 2 3 2 1 . 1 1 1 1 1 4 . 1 2 3 . 2 3 2
#! . 2 1 . 1 4 3 1 4 . 2 2 3 4 1 2 . 3 . . 3 4 2 1 1 3 4 3 1 1 3 . 3 . 3 4 4 3 3 3
#! 1 1 2 2 . 1 . 4 4 1 1 . 3 2 1 . . 4 2 1 . . 3 3 3 4 . 2 1 4 1 1 1 3 3 4 1 3 4 4
#! 3 4 2 4 1 1 . 1 4 3 4 1 1 1 . 2 . 1 2 4 4 . 2 1 3 4 1 . 4 1 2 4 . 1 1 4 1 1 4 2
#! 2 4 2 . 4 1 4 . 3 2 3 . 1 3 1 4 2 4 2 2 3 1 4 4 4 1 1 4 . . 2 . 3 3 1 3 2 . 3 3
#! 2 . . 3 . . 3 3 3 . . 1 1 . 2 4 1 1 . . 1 1 1 . 3 1 2 1 2 4 3 3 2 4 . 4 . 3 4 4
#! . 3 . 2 3 4 1 1 3 . 1 3 3 . 1 4 1 4 . 4 4 4 2 . 1 3 4 3 3 . 2 4 . 1 1 1 2 4 3 3
#! 4 3 . 1 3 1 2 4 2 1 1 4 3 . 2 1 2 . 4 . 1 4 2 2 1 2 4 . 2 3 3 2 1 2 4 2 2 3 3 3
#! 1 . . 2 4 4 4 3 4 1 4 4 2 . 1 3 . 1 3 4 3 1 2 4 3 2 . 1 4 3 1 4 4 2 4 2 . . 4 3
#! 1 . 2 4 4 1 3 4 4 3 1 4 3 2 2 4 2 4 . 2 1 1 3 1 4 . 3 4 2 1 3 2 4 2 1 4 4 1 4 3
#! 4 . 4 1 1 2 1 4 4 . 3 2 . . 2 1 . 3 2 2 4 2 . 2 . 3 3 1 1 1 4 . 3 4 4 4 2 . 1 2
#! 2 4 3 . 4 2 1 . 1 . 4 3 4 3 1 2 4 . 3 2 . 4 3 2 1 2 3 3 4 3 . 4 4 . 4 3 3 . 4 .
#! 2 2 . 3 1 3 3 4 2 2 1 1 2 2 1 1 4 4 . 4 2 . 2 4 3 . 4 2 3 4 2 4 . 3 . 4 3 . 3 .
#! 2 4 1 3 2 3 3 . 1 . 4 3 . 2 2 3 . 2 3 1 1 1 2 3 . 4 1 3 1 . 3 3 4 . 3 2 . 4 4 4
]]></Example>


<P/>
We start with the most basic version which just takes A as the argument and computes its RREF (whithout zero rows). It is not necessary to set any additional parameters, however, in this case the input matrix is not split into smaller blocks, so this is not the optimal use of the algorithm.
<P/>
<Example><![CDATA[
#! gap> result := EchelonMatBlockwise( A );
#! #I  The matrix is split into 4 blocks vertically and 4 horizontally.
#! rec( heads := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
#!   19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
#!     vectors := < immutable compressed matrix 28x40 over GF(5) > )
#! gap> Display( result.vectors );
#! 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 4 4 . 1 3 2 4 3 . 3
#! . 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 . 2 2 3 4 2 2 2 4 1
#! . . 1 . . . . . . . . . . . . . . . . . . . . . . . . . 4 . 3 3 3 1 . 1 3 1 . 4
#! . . . 1 . . . . . . . . . . . . . . . . . . . . . . . . 4 2 1 1 4 3 . . 3 4 1 2
#! . . . . 1 . . . . . . . . . . . . . . . . . . . . . . . . 4 2 4 3 2 1 2 2 . 4 .
#! . . . . . 1 . . . . . . . . . . . . . . . . . . . . . . 2 1 3 2 1 4 . 4 4 1 2 4
#! . . . . . . 1 . . . . . . . . . . . . . . . . . . . . . 1 . 3 4 . 3 . 2 3 1 2 1
#! . . . . . . . 1 . . . . . . . . . . . . . . . . . . . . 3 3 . 4 4 2 2 2 1 3 3 1
#! . . . . . . . . 1 . . . . . . . . . . . . . . . . . . . 3 2 4 4 . 3 4 3 2 4 2 2
#! . . . . . . . . . 1 . . . . . . . . . . . . . . . . . . . 3 4 3 1 . 1 2 2 . 1 .
#! . . . . . . . . . . 1 . . . . . . . . . . . . . . . . . 2 . 3 1 1 1 . 4 4 1 2 2
#! . . . . . . . . . . . 1 . . . . . . . . . . . . . . . . 1 3 4 1 1 4 3 1 1 2 2 .
#! . . . . . . . . . . . . 1 . . . . . . . . . . . . . . . 1 3 4 4 3 4 . 3 . 2 1 3
#! . . . . . . . . . . . . . 1 . . . . . . . . . . . . . . . 3 1 1 2 . 3 . 2 1 1 .
#! . . . . . . . . . . . . . . 1 . . . . . . . . . . . . . . 2 2 . 3 4 3 . 4 . 2 1
#! . . . . . . . . . . . . . . . 1 . . . . . . . . . . . . 4 3 . . . 2 3 . 3 . 3 3
#! . . . . . . . . . . . . . . . . 1 . . . . . . . . . . . 4 4 1 2 . . 4 . 2 3 . 4
#! . . . . . . . . . . . . . . . . . 1 . . . . . . . . . . . . 4 3 4 3 1 3 3 3 . 1
#! . . . . . . . . . . . . . . . . . . 1 . . . . . . . . . 1 . 3 3 4 4 4 4 1 1 1 3
#! . . . . . . . . . . . . . . . . . . . 1 . . . . . . . . . 1 2 3 1 2 . 2 3 3 2 2
#! . . . . . . . . . . . . . . . . . . . . 1 . . . . . . . 1 2 4 3 . 2 3 4 2 3 3 3
#! . . . . . . . . . . . . . . . . . . . . . 1 . . . . . . 2 3 4 3 2 1 1 2 . 1 4 2
#! . . . . . . . . . . . . . . . . . . . . . . 1 . . . . . 2 1 4 1 4 2 4 4 3 . . 1
#! . . . . . . . . . . . . . . . . . . . . . . . 1 . . . . 4 4 3 4 1 2 4 3 2 . 1 2
#! . . . . . . . . . . . . . . . . . . . . . . . . 1 . . . 3 . 3 . 4 2 . 3 3 2 2 .
#! . . . . . . . . . . . . . . . . . . . . . . . . . 1 . . 4 . . 2 3 2 1 3 4 1 . 1
#! . . . . . . . . . . . . . . . . . . . . . . . . . . 1 . 1 3 2 2 . 4 . . 4 3 2 3
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 2 3 4 3 3 1 1 . 3 4 4 .
]]></Example>


<P/>
This version additionally computes the transformation matrix.
<P/>
<Example><![CDATA[
#! gap> result2 := EchelonMatTransformationBlockwise( A );
#! #I  The matrix is split into 4 blocks vertically and 4 horizontally.
#! rec( coeffs := < immutable compressed matrix 28x40 over GF(5) >,
#!     heads := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
#!       20, 21, 22, 23, 24, 25, 26, 27, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
#!     relations := < immutable compressed matrix 12x40 over GF(5) >,
#!     vectors := < immutable compressed matrix 28x40 over GF(5) > )
#! gap> Display( result2.relations );
#! 4 4 3 1 2 1 . 4 . 3 4 2 4 3 . 2 1 . 1 3 3 . 2 1 . 3 3 . 1 . . . . . . . . . . .
#! . 2 2 2 3 4 1 2 3 . 3 1 2 1 3 3 2 . 3 4 1 2 3 . 1 . 1 1 . 1 . . . . . . . . . .
#! 2 . 4 . . 2 4 2 4 . . 1 1 4 3 3 2 . . . 4 . 1 1 1 2 . 4 . . 1 . . . . . . . . .
#! 1 2 . 2 2 . 3 4 3 4 1 1 . 3 2 4 . 3 2 3 2 . 2 3 1 2 3 4 . . . 1 . . . . . . . .
#! 3 2 3 1 2 . 3 3 1 4 2 . 3 1 . 3 . 1 1 4 1 1 4 4 . 1 2 1 . . . . 1 . . . . . . .
#! 2 . 4 . 3 2 4 1 3 4 1 2 . 1 3 4 4 3 . 4 2 4 4 3 4 1 1 4 . . . . . 1 . . . . . .
#! . . 2 . . 3 2 . 3 2 4 3 4 . 1 . 2 2 1 3 3 3 3 2 2 3 . . . . . . . . 1 . . . . .
#! . 3 1 . 4 2 1 3 4 3 . 1 4 3 3 . 1 2 2 2 1 2 3 2 4 3 4 2 . . . . . . . 1 . . . .
#! 1 . 3 2 2 1 2 3 4 2 1 . 2 2 1 2 . 3 3 4 2 3 2 1 3 1 1 4 . . . . . . . . 1 . . .
#! 1 3 2 2 2 1 3 4 4 4 4 3 3 1 3 4 2 1 3 2 1 3 2 1 . 3 . . . . . . . . . . . 1 . .
#! 1 . 2 1 . . 4 . . 2 . 2 3 4 3 1 1 4 3 1 1 4 4 4 2 2 1 4 . . . . . . . . . . 1 .
#! 4 3 3 1 . 3 4 3 3 1 . 4 2 2 . 4 2 4 3 4 . 1 . . . 3 3 4 . . . . . . . . . . . 1
#! gap> Display( Concatenation( result2.coeffs, result2.relations ) * A );
#! 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 4 4 . 1 3 2 4 3 . 3
#! . 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 . 2 2 3 4 2 2 2 4 1
#! . . 1 . . . . . . . . . . . . . . . . . . . . . . . . . 4 . 3 3 3 1 . 1 3 1 . 4
#! . . . 1 . . . . . . . . . . . . . . . . . . . . . . . . 4 2 1 1 4 3 . . 3 4 1 2
#! . . . . 1 . . . . . . . . . . . . . . . . . . . . . . . . 4 2 4 3 2 1 2 2 . 4 .
#! . . . . . 1 . . . . . . . . . . . . . . . . . . . . . . 2 1 3 2 1 4 . 4 4 1 2 4
#! . . . . . . 1 . . . . . . . . . . . . . . . . . . . . . 1 . 3 4 . 3 . 2 3 1 2 1
#! . . . . . . . 1 . . . . . . . . . . . . . . . . . . . . 3 3 . 4 4 2 2 2 1 3 3 1
#! . . . . . . . . 1 . . . . . . . . . . . . . . . . . . . 3 2 4 4 . 3 4 3 2 4 2 2
#! . . . . . . . . . 1 . . . . . . . . . . . . . . . . . . . 3 4 3 1 . 1 2 2 . 1 .
#! . . . . . . . . . . 1 . . . . . . . . . . . . . . . . . 2 . 3 1 1 1 . 4 4 1 2 2
#! . . . . . . . . . . . 1 . . . . . . . . . . . . . . . . 1 3 4 1 1 4 3 1 1 2 2 .
#! . . . . . . . . . . . . 1 . . . . . . . . . . . . . . . 1 3 4 4 3 4 . 3 . 2 1 3
#! . . . . . . . . . . . . . 1 . . . . . . . . . . . . . . . 3 1 1 2 . 3 . 2 1 1 .
#! . . . . . . . . . . . . . . 1 . . . . . . . . . . . . . . 2 2 . 3 4 3 . 4 . 2 1
#! . . . . . . . . . . . . . . . 1 . . . . . . . . . . . . 4 3 . . . 2 3 . 3 . 3 3
#! . . . . . . . . . . . . . . . . 1 . . . . . . . . . . . 4 4 1 2 . . 4 . 2 3 . 4
#! . . . . . . . . . . . . . . . . . 1 . . . . . . . . . . . . 4 3 4 3 1 3 3 3 . 1
#! . . . . . . . . . . . . . . . . . . 1 . . . . . . . . . 1 . 3 3 4 4 4 4 1 1 1 3
#! . . . . . . . . . . . . . . . . . . . 1 . . . . . . . . . 1 2 3 1 2 . 2 3 3 2 2
#! . . . . . . . . . . . . . . . . . . . . 1 . . . . . . . 1 2 4 3 . 2 3 4 2 3 3 3
#! . . . . . . . . . . . . . . . . . . . . . 1 . . . . . . 2 3 4 3 2 1 1 2 . 1 4 2
#! . . . . . . . . . . . . . . . . . . . . . . 1 . . . . . 2 1 4 1 4 2 4 4 3 . . 1
#! . . . . . . . . . . . . . . . . . . . . . . . 1 . . . . 4 4 3 4 1 2 4 3 2 . 1 2
#! . . . . . . . . . . . . . . . . . . . . . . . . 1 . . . 3 . 3 . 4 2 . 3 3 2 2 .
#! . . . . . . . . . . . . . . . . . . . . . . . . . 1 . . 4 . . 2 3 2 1 3 4 1 . 1
#! . . . . . . . . . . . . . . . . . . . . . . . . . . 1 . 1 3 2 2 . 4 . . 4 3 2 3
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 2 3 4 3 3 1 1 . 3 4 4 .
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
#! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
]]></Example>


<P/>
TODO: more examples on parameters.
TODO: remove the following examples (?).
This version is the most adjustable one - see chapter 2.2 for more information.
You can specify the field of the matrix and whether or not you need the
transformation matrix (extra calculation is needed, so it makes sense to
disable the calculation if you don't need it and calculate many matrices).
<P/>
<Example><![CDATA[
#! gap> DoEchelonMatTransformationBlockwise( A,
#! > rec( galoisField := GF( 5 ), withTrafo := false ) );
#! #I The matrix is split into 4 blocks vertically and 4 horizontally.
#! rec( coeffs := < immutable compressed matrix 28x40 over GF(5) >,
#!   heads := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
#!       20, 21, 22, 23, 24, 25, 26, 27, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
#!   pivotcols := [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
#!       1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
#!   pivotrows := [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
#!       1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
#!   rank := 28,
]]></Example>


<P/>
Our package is still in a beta version and although we ran a lot of tests,
it makes sense to verify the results directly to be one hundred percent sure of
the outcome. If you pass the following argument, the function tests internally
before returning the results.
<P/>
<Example><![CDATA[
#! gap> DoEchelonMatTransformationBlockwise( A, rec( verify := true ) );
#! #I The matrix is split into 4 blocks vertically and 4 horizontally.
#! rec( coeffs := < immutable compressed matrix 28x40 over GF(5) >,
#!   heads := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
#!       20, 21, 22, 23, 24, 25, 26, 27, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
#!   pivotcols := [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
#!       1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
#!   pivotrows := [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
#!       1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
#!   rank := 28,
#!   relations := < immutable compressed matrix 12x40 over GF(5) >,
#!   transformation := < mutable compressed matrix 40x40 over GF(5) >,
#!   vectors := < immutable compressed matrix 28x40 over GF(5) > )
]]></Example>


<P/>
Using the following arguments you can specify the number of blocks yourself.
<P/>
<Example><![CDATA[
#! gap> DoEchelonMatTransformationBlockwise( A,
#! > rec( numberBlocksHeight := 2, numberBlocksWidth := 4 ) );
#! #I The matrix is split into 2 blocks vertically and 4 horizontally.
#! rec( coeffs := < immutable compressed matrix 28x40 over GF(5) >,
#!   heads := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
#!       20, 21, 22, 23, 24, 25, 26, 27, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
#!   pivotcols := [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
#!       1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
#!   pivotrows := [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
#!       1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
#!   rank := 28,
#!   relations := < immutable compressed matrix 12x40 over GF(5) >,
#!   transformation := < mutable compressed matrix 40x40 over GF(5) >,
#!   vectors := < immutable compressed matrix 28x40 over GF(5) > )
]]></Example>


<P/>
If you want to calculate the GAUSS algorithm on a matrix that is already
chopped (this could be useful for blocks of different sizes), write
TODO is this possible with blocks of different sizes??!!
<P/>
<Example><![CDATA[
#! gap> DoEchelonMatTransformationBlockwise( A, rec( isChopped := true ) );;
]]></Example>


<P/>
</Chapter>

